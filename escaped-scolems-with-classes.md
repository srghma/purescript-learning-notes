# error at runtime

```purs
import Prelude
import Unsafe.Coerce
import Effect.Console
import Effect

newtype Foo content hiddenContent = Foo { content :: content, hiddenContent :: hiddenContent }

class MyClass a where
  myClassFunc :: a -> String

instance myClassInt :: MyClass Int where
  myClassFunc _ = "MyClass Int"

instance myClassString :: MyClass String where
  myClassFunc _ = "MyClass String"

data FooX (content :: Type) -- hides internal representation, X or Box postfix

mkFooX
  :: forall content hiddenContent
   . (Foo content hiddenContent)
  -> (FooX content)
mkFooX = unsafeCoerce

unFooX
  :: forall content a
   . (forall hiddenContent. MyClass hiddenContent => Foo content hiddenContent -> a) -- will throw error if `hiddenContent` escapes this function
  -> FooX content
  -> a
unFooX = unsafeCoerce

foo1 :: Foo String Int
foo1 = Foo { content: "content", hiddenContent: 42  }

fooX1 :: FooX String
fooX1 = mkFooX foo1

foo2 :: Foo String String
foo2 = Foo { content: "content", hiddenContent: "hiddenContent"  }

fooX2 :: FooX String
fooX2 = mkFooX foo2

{-
  var testCorrect = unFooX(function (dictMyClass) {
      console.log('dictMyClass', dictMyClass) // dictMyClass { content: 'content', hiddenContent: 42 }
      return function (v) {
          console.log('v', v) // not called
          return myClassFunc(dictMyClass)(v.hiddenContent);
      };
  })(fooX1);
-}
testCorrect :: String
testCorrect = unFooX (\(Foo { content, hiddenContent }) -> myClassFunc hiddenContent) fooX1

main :: Effect Unit
main = do
  log testCorrect -- [Function (anonymous)]
```

```js
// Generated by purs version 0.13.6
"use strict";
var Effect_Console = require("../Effect.Console/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = Unsafe_Coerce.unsafeCoerce;
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var mkFooX = Unsafe_Coerce.unsafeCoerce;
var foo2 = {
    content: "content",
    hiddenContent: "hiddenContent"
};
var fooX2 = mkFooX(foo2);
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(foo1);
var testCorrect = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = Effect_Console.log(testCorrect);
module.exports = {
    myClassFunc: myClassFunc,
    Foo: Foo,
    MyClass: MyClass,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect: testCorrect,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString
};
```

-----------------------------------------

```purs
{-
  var mkFooX = function (dictMyClass) {
      return Unsafe_Coerce.unsafeCoerce;
  };
-}
mkFooX
  :: forall content hiddenContent
   . MyClass hiddenContent
  => (Foo content hiddenContent)
  -> (FooX content)
mkFooX = unsafeCoerce
```


```js

// Generated by purs version 0.13.6
"use strict";
var Effect_Console = require("../Effect.Console/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = Unsafe_Coerce.unsafeCoerce;
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var mkFooX = function (dictMyClass) {
    return Unsafe_Coerce.unsafeCoerce;
};
var foo2 = {
    content: "content",
    hiddenContent: "hiddenContent"
};
var fooX2 = mkFooX(myClassString)(foo2);
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(myClassInt)(foo1);
var testCorrect = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = Effect_Console.log(testCorrect);
module.exports = {
    myClassFunc: myClassFunc,
    Foo: Foo,
    MyClass: MyClass,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect: testCorrect,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString
};
```

-----------------------------------------


```purs
mkFooX
  :: forall content hiddenContent
   . (MyClass hiddenContent => Foo content hiddenContent)
  -> (FooX content)
mkFooX = unsafeCoerce
```


```js
// Generated by purs version 0.13.6
"use strict";
var Effect_Console = require("../Effect.Console/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = Unsafe_Coerce.unsafeCoerce;
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var mkFooX = Unsafe_Coerce.unsafeCoerce;
var foo2 = {
    content: "content",
    hiddenContent: "hiddenContent"
};
var fooX2 = mkFooX(function (dictMyClass) {
    return foo2;
});
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(function (dictMyClass) {
    return foo1;
});
var testCorrect = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = Effect_Console.log(testCorrect);
module.exports = {
    myClassFunc: myClassFunc,
    Foo: Foo,
    MyClass: MyClass,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect: testCorrect,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString
};
```

------------------------------------------------



# Correct implementation


```purs
module Halogen.MDL.Button where

import Effect
import Effect.Console
import Prelude
import Type.Proxy
import Unsafe.Coerce

class MyClass a where
  myClassFunc :: a -> String

instance myClassInt :: MyClass Int where
  myClassFunc _ = "MyClass Int"

instance myClassString :: MyClass String where
  myClassFunc _ = "MyClass String"

type MyClassDict a = { myClassFunc :: a -> String }

mkMyClassDict :: forall a . MyClass a => Proxy a -> MyClassDict a
mkMyClassDict _ = { myClassFunc }

------------------------------------

newtype Foo content hiddenContent = Foo { content :: content, hiddenContent :: hiddenContent }

type FooXInternals content hiddenContent = { value :: Foo content hiddenContent, myClassDict :: MyClassDict hiddenContent }
data FooX (content :: Type) -- hides internal representation, X or Box postfix

mkFooX
  :: forall content hiddenContent
   . MyClass hiddenContent
  => (Foo content hiddenContent)
  -> (FooX content)
mkFooX a@(Foo { hiddenContent }) = unsafeCoerce { value: a, myClassDict: mkMyClassDict (Proxy :: Proxy hiddenContent) }

unFooX
  :: forall content a
   . (forall hiddenContent. MyClass hiddenContent => Foo content hiddenContent -> a) -- will throw error if `hiddenContent` escapes this function
  -> FooX content
  -> a
unFooX = unsafeCoerce unFooXImplementation

unFooXImplementation
  :: forall content a hiddenContent
   . (Foo content hiddenContent -> a) -- will throw error if `hiddenContent` escapes this function
  -> FooX content
  -> a
unFooXImplementation f fooX =
  let ({ value, myClassDict }) = unsafeCoerce fooX
      (f' :: MyClassDict hiddenContent -> Foo content hiddenContent -> a) = unsafeCoerce f
    in f' myClassDict value

foo1 :: Foo String Int
foo1 = Foo { content: "content", hiddenContent: 42  }

fooX1 :: FooX String
fooX1 = mkFooX foo1

foo2 :: Foo String String
foo2 = Foo { content: "content", hiddenContent: "hiddenContent"  }

fooX2 :: FooX String
fooX2 = mkFooX foo2

testCorrect1 :: String
testCorrect1 = unFooX (\(Foo { content, hiddenContent }) -> myClassFunc hiddenContent) fooX1

testCorrect2 :: String
testCorrect2 = unFooX (\(Foo { content, hiddenContent }) -> myClassFunc hiddenContent) fooX2

main :: Effect Unit
main = do
  log testCorrect1 -- MyClass Int
  log testCorrect2 -- MyClass String
```
