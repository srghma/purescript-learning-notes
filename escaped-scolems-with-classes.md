# TLDR; Correct implementation


```purs
module Halogen.MDL.Button where

import Effect
import Effect.Console
import Prelude
import Type.Proxy
import Data.Foldable
import Unsafe.Coerce

class MyClass a where
  myClassFunc :: a -> String

instance myClassInt :: MyClass Int where
  myClassFunc _ = "MyClass Int"

instance myClassString :: MyClass String where
  myClassFunc _ = "MyClass String"

instance myClassArrayString :: MyClass a => MyClass (Array a) where
  myClassFunc xs = "MyClass Array: " <> intercalate ", " (map myClassFunc xs)

type MyClassDict a = { myClassFunc :: a -> String }

mkMyClassDict :: forall a . MyClass a => Proxy a -> MyClassDict a
mkMyClassDict _ = { myClassFunc }

------------------------------------

newtype Foo content hiddenContent = Foo { content :: content, hiddenContent :: hiddenContent }

type FooXInternals content hiddenContent = { value :: Foo content hiddenContent, myClassDict :: MyClassDict hiddenContent }
data FooX (content :: Type) -- hides internal representation, X or Box postfix

mkFooX
  :: forall content hiddenContent
   . MyClass hiddenContent
  => (Foo content hiddenContent)
  -> (FooX content)
mkFooX a@(Foo { hiddenContent }) = unsafeCoerce { value: a, myClassDict: mkMyClassDict (Proxy :: Proxy hiddenContent) }

unFooX
  :: forall content a
   . (forall hiddenContent. MyClass hiddenContent => Foo content hiddenContent -> a) -- will throw error if `hiddenContent` escapes this function
  -> FooX content
  -> a
unFooX = unsafeCoerce unFooXImplementation
  where
        unFooXImplementation
          :: forall hiddenContent
           . (Foo content hiddenContent -> a)
          -> FooX content
          -> a
        unFooXImplementation f fooX =
          let ({ value, myClassDict } :: FooXInternals content hiddenContent) = unsafeCoerce fooX
              (f' :: MyClassDict hiddenContent -> Foo content hiddenContent -> a) = unsafeCoerce f
            in f' myClassDict value

foo1 :: Foo String Int
foo1 = Foo { content: "content", hiddenContent: 42  }

fooX1 :: FooX String
fooX1 = mkFooX foo1

foo2 :: Foo String (Array String)
foo2 = Foo { content: "content", hiddenContent: ["hiddenContent1", "hiddenContent2"]  }

fooX2 :: FooX String
fooX2 = mkFooX foo2

testCorrect1 :: String
testCorrect1 = unFooX (\(Foo { content, hiddenContent }) -> myClassFunc hiddenContent) fooX1

testCorrect2 :: String
testCorrect2 = unFooX (\(Foo { content, hiddenContent }) -> myClassFunc hiddenContent) fooX2

main :: Effect Unit
main = do
  log testCorrect1 -- MyClass Int
  log testCorrect2 -- MyClass Array: MyClass String, MyClass String
```

```js
// Generated by purs version 0.13.6
"use strict";
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Effect_Console = require("../Effect.Console/index.js");
var Type_Proxy = require("../Type.Proxy/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = (function () {
    var unFooXImplementation = function (f) {
        return function (fooX) {
            return f(fooX.myClassDict)(fooX.value);
        };
    };
    return unFooXImplementation;
})();
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var myClassArrayString = function (dictMyClass) {
    return new MyClass(function (xs) {
        return "MyClass Array: " + Data_Foldable.intercalate(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(", ")(Data_Functor.map(Data_Functor.functorArray)(myClassFunc(dictMyClass))(xs));
    });
};
var mkMyClassDict = function (dictMyClass) {
    return function (v) {
        return {
            myClassFunc: myClassFunc(dictMyClass)
        };
    };
};
var mkFooX = function (dictMyClass) {
    return function (v) {
        return {
            value: v,
            myClassDict: mkMyClassDict(dictMyClass)(Type_Proxy["Proxy"].value)
        };
    };
};
var foo2 = {
    content: "content",
    hiddenContent: [ "hiddenContent1", "hiddenContent2" ]
};
var fooX2 = mkFooX(myClassArrayString(myClassString))(foo2);
var testCorrect2 = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX2);
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(myClassInt)(foo1);
var testCorrect1 = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = function __do() {
    Effect_Console.log(testCorrect1)();
    return Effect_Console.log(testCorrect2)();
};
module.exports = {
    myClassFunc: myClassFunc,
    MyClass: MyClass,
    mkMyClassDict: mkMyClassDict,
    Foo: Foo,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect1: testCorrect1,
    testCorrect2: testCorrect2,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString,
    myClassArrayString: myClassArrayString
};
```

------------------------------------------------



# Incorrect implementation, error at runtime

```purs
import Prelude
import Unsafe.Coerce
import Effect.Console
import Effect

newtype Foo content hiddenContent = Foo { content :: content, hiddenContent :: hiddenContent }

class MyClass a where
  myClassFunc :: a -> String

instance myClassInt :: MyClass Int where
  myClassFunc _ = "MyClass Int"

instance myClassString :: MyClass String where
  myClassFunc _ = "MyClass String"

data FooX (content :: Type) -- hides internal representation, X or Box postfix

mkFooX
  :: forall content hiddenContent
   . (Foo content hiddenContent)
  -> (FooX content)
mkFooX = unsafeCoerce

unFooX
  :: forall content a
   . (forall hiddenContent. MyClass hiddenContent => Foo content hiddenContent -> a) -- will throw error if `hiddenContent` escapes this function
  -> FooX content
  -> a
unFooX = unsafeCoerce

foo1 :: Foo String Int
foo1 = Foo { content: "content", hiddenContent: 42  }

fooX1 :: FooX String
fooX1 = mkFooX foo1

foo2 :: Foo String String
foo2 = Foo { content: "content", hiddenContent: "hiddenContent"  }

fooX2 :: FooX String
fooX2 = mkFooX foo2

{-
  var testCorrect = unFooX(function (dictMyClass) {
      console.log('dictMyClass', dictMyClass) // dictMyClass { content: 'content', hiddenContent: 42 }
      return function (v) {
          console.log('v', v) // not called
          return myClassFunc(dictMyClass)(v.hiddenContent);
      };
  })(fooX1);
-}
testCorrect :: String
testCorrect = unFooX (\(Foo { content, hiddenContent }) -> myClassFunc hiddenContent) fooX1

main :: Effect Unit
main = do
  log testCorrect -- [Function (anonymous)]
```

```js
// Generated by purs version 0.13.6
"use strict";
var Effect_Console = require("../Effect.Console/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = Unsafe_Coerce.unsafeCoerce;
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var mkFooX = Unsafe_Coerce.unsafeCoerce;
var foo2 = {
    content: "content",
    hiddenContent: "hiddenContent"
};
var fooX2 = mkFooX(foo2);
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(foo1);
var testCorrect = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = Effect_Console.log(testCorrect);
module.exports = {
    myClassFunc: myClassFunc,
    Foo: Foo,
    MyClass: MyClass,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect: testCorrect,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString
};
```

-----------------------------------------

# incorrect 2

```purs
{-
  var mkFooX = function (dictMyClass) {
      return Unsafe_Coerce.unsafeCoerce;
  };
-}
mkFooX
  :: forall content hiddenContent
   . MyClass hiddenContent
  => (Foo content hiddenContent)
  -> (FooX content)
mkFooX = unsafeCoerce
```

```js

// Generated by purs version 0.13.6
"use strict";
var Effect_Console = require("../Effect.Console/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = Unsafe_Coerce.unsafeCoerce;
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var mkFooX = function (dictMyClass) {
    return Unsafe_Coerce.unsafeCoerce;
};
var foo2 = {
    content: "content",
    hiddenContent: "hiddenContent"
};
var fooX2 = mkFooX(myClassString)(foo2);
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(myClassInt)(foo1);
var testCorrect = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = Effect_Console.log(testCorrect);
module.exports = {
    myClassFunc: myClassFunc,
    Foo: Foo,
    MyClass: MyClass,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect: testCorrect,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString
};
```

-----------------------------------------

# incorrect 3

```purs
mkFooX
  :: forall content hiddenContent
   . (MyClass hiddenContent => Foo content hiddenContent)
  -> (FooX content)
mkFooX = unsafeCoerce
```


```js
// Generated by purs version 0.13.6
"use strict";
var Effect_Console = require("../Effect.Console/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var Foo = function (x) {
    return x;
};
var MyClass = function (myClassFunc) {
    this.myClassFunc = myClassFunc;
};
var unFooX = Unsafe_Coerce.unsafeCoerce;
var myClassString = new MyClass(function (v) {
    return "MyClass String";
});
var myClassInt = new MyClass(function (v) {
    return "MyClass Int";
});
var myClassFunc = function (dict) {
    return dict.myClassFunc;
};
var mkFooX = Unsafe_Coerce.unsafeCoerce;
var foo2 = {
    content: "content",
    hiddenContent: "hiddenContent"
};
var fooX2 = mkFooX(function (dictMyClass) {
    return foo2;
});
var foo1 = {
    content: "content",
    hiddenContent: 42
};
var fooX1 = mkFooX(function (dictMyClass) {
    return foo1;
});
var testCorrect = unFooX(function (dictMyClass) {
    return function (v) {
        return myClassFunc(dictMyClass)(v.hiddenContent);
    };
})(fooX1);
var main = Effect_Console.log(testCorrect);
module.exports = {
    myClassFunc: myClassFunc,
    Foo: Foo,
    MyClass: MyClass,
    mkFooX: mkFooX,
    unFooX: unFooX,
    foo1: foo1,
    fooX1: fooX1,
    foo2: foo2,
    fooX2: fooX2,
    testCorrect: testCorrect,
    main: main,
    myClassInt: myClassInt,
    myClassString: myClassString
};
```
